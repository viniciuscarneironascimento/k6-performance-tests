ESTUDO TESTE DE PERFORMANCE COM K6

Teste de performance √© dividido assim:

‚Ä¢	Teste de carga: avaliar o comportamento do sistema sob uma carga esperada. Ex: quando descobri o ponto de falha (com teste de stress), ent√£o realizo teste dentro de uma carga esperada sem provocar erros.

‚Ä¢	Teste de stress: identificar o ponto de falha do sistema, simulando condi√ß√µes extremas e al√©m da capacidade m√°xima do sistema. Ex: estressar a aplica√ß√£o at√© descobrir onde ela falha. Execute testes de estresse somente ap√≥s executar testes de carga m√©dia. Identifique problemas de desempenho em testes de carga m√©dia antes de tentar algo mais desafiador. Esta sequ√™ncia √© essencial.

‚Ä¢	Teste de pico: avalia a resposta do sistema sob picos s√∫bitos e inesperados de tr√°fego. Ex: promo√ß√£o de vendas com grande quantidade de acessos de uma vez.

‚Ä¢	Teste de resili√™ncia: testa a capacidade do sistema de manter um desempenho est√°vel ao longo de um per√≠odo prolongado.


M√©tricas de performance:

‚Ä¢	Tempo de resposta: medir o tempo que o sistema leva para processar uma requisi√ß√£o e responder ao usu√°rio (idealmente deve ser inferior a 2 segundos)
‚Ä¢	Taxa de transfer√™ncias
‚Ä¢	Uso de recursos do sistema (CPU, mem√≥ria)
‚Ä¢	Erros e falhas (Ex: erro 500 ou 400 ou falhas de carregamento)
‚Ä¢	Troughput (requisi√ß√µes bem-sucedidas por minuto)
‚Ä¢	Conex√µes simult√¢neas
------------------------------------------------------------------------------------------------------------------------------------------


Projeto ‚Äì 1¬™ etapa
Execu√ß√£o Local (via CLI)

1- Instala√ß√£o do K6 CLI  (s√≥ pode ser via linha de comando: choco install k6).
2- Cria√ß√£o de uma estrutura de pastas no VS Code.
3- Cria√ß√£o de um script b√°sico com aux√≠lio do ChatGpt.
4- Execu√ß√£o via terminal com sa√≠da de dados b√°sicos no pr√≥prio terminal e gera√ß√£o de result JSON para uso no relat√≥rio:  k6 run scripts/teste-basico.js --out json=results/result.json

CONCLUS√ÉO:
Seu notebook simula 10 usu√°rios virtuais (VUs), que abrem conex√µes HTTP e fazem as requisi√ß√µes para o servidor na URL https://test.k6.io. O servidor s√≥ responde.
O resultado que o K6 gera no seu notebook reflete a performance da URL que voc√™ est√° testando, ou seja, o servidor remoto (https://test.k6.io).
Por√©m, o processamento dos 10 acessos simult√¢neos definidos no script de teste, ou seja, a simula√ß√£o dos usu√°rios realizando as requisi√ß√µes √© todo realizado pelo seu notebook que executou o comando.
Desta forma, se seu notebook n√£o conseguir acompanhar a carga configurada (exemplo: 10 VUs simult√¢neos ou mais), por limita√ß√µes de CPU, mem√≥ria ou rede e travar, o K6 n√£o vai conseguir gerar o tr√°fego esperado de forma correta.
Para n√£o sobrecarregar sua m√°quina local e ainda executar testes robustos com o K6, use:
‚Ä¢	Um ambiente dedicado para gerar carga
‚Ä¢	Servidor na nuvem (AWS, GCP, Azure, etc)
‚Ä¢	Configure uma VM com recursos adequados para rodar o K6 e gerar a carga.
‚Ä¢	Voc√™ roda o script remotamente e coleta os resultados sem consumir recursos do seu notebook.

Utilize o K6 Cloud (esta solu√ß√£o farei na etapa 3)
O K6 Cloud permite voc√™ subir o script e rodar testes distribu√≠dos com alta escala, sem depender do seu computador. Voc√™ s√≥ precisa enviar o script e visualizar os resultados no painel web, e a gera√ß√£o da carga fica totalmente na infraestrutura deles.
------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì 2¬™ etapa
Converter os dados gerados em relat√≥rio HTML

1- Para gerar relat√≥rio HTML, foi necess√°rio instalar Node.js: npm init -y
Depois instalar o k6-html-reporter: npm install --save-dev k6-html-reporter
k6 run --out json=results/result.json scripts/teste-basico.js
k6 convert results/result.json -O results.html

CONCLUS√ÉO: depois de in√∫meras tentativas para tentar converter os dados JSON em relat√≥rio html, irei buscar outra op√ß√£o.
Ao adicionar o import e a fun√ß√£o handleSummary dentro do script de testes, foi poss√≠vel gerar um relat√≥rio html.
Basta executar o comando b√°sico: k6 run scripts/teste-basico.js

// Importa os geradores de relat√≥rio HTML e texto para o summary
import { htmlReport } from 'https://raw.githubusercontent.com/benc-uk/k6-reporter/main/dist/bundle.js';
import { textSummary } from 'https://jslib.k6.io/k6-summary/0.0.1/index.js';

// Gera o relat√≥rio HTML ao final do teste
export function handleSummary(data) {
  return {
    'summary.html': htmlReport(data), // Gera arquivo HTML
    stdout: textSummary(data, { indent: ' ', enableColors: true }), // Mostra resumo no terminal
  };
}

------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì 3¬™ etapa
Utilizar cloud para reproduzir os resultados

1- O que voc√™ precisa para usar o K6 Cloud (Grafana Cloud K6):
‚Ä¢	Conta gratuita ou paga no Grafana Cloud com o m√≥dulo de K6 ativado.
‚Ä¢	Script de teste local em JavaScript, com a extens√£o .js.
‚Ä¢	Instala√ß√£o do K6 CLI localmente em sua m√°quina (vide etapa 1).
‚Ä¢	Autentica√ß√£o via token de API da K6 Cloud.

2- Comando para realizar o login: k6 cloud login

Retorno no terminal:  Enter your token to authenticate with Grafana Cloud k6. Please, consult the Grafana Cloud k6 documentation for instructions on how to generate one: https://grafana.com/docs/grafana-cloud/testing/k6/author-run/tokens-and-cli-authentication

3- Acessar k6 Testing & synthetics / Performance / Settings ‚Äì Stack token
Comando para realizar login com token:
k6 cloud login --token 8b098c7b1ffcf75867fd59d01f052ee3da683287cf1f0c924b27c4b62773c0f7
 


4- Comando para executar os testes no K6 Cloud
Bash:  k6 cloud scripts/teste-basico.js

O terminal mostra URL onde ser√° executado os testes na nuvem exemplo: 
https://contatovinicius.grafana.net/a/k6-app/runs/4818175


CONCLUS√ÉO:
Com K6 Cloud voc√™ dispara o teste a partir do seu notebook, mas a execu√ß√£o real ocorre nos servidores da nuvem do K6, sem consumir quase nada dos recursos da sua m√°quina. Como isso funciona:
‚Ä¢	Seu notebook envia o script de teste para a plataforma K6 Cloud.
‚Ä¢	A execu√ß√£o acontece nos servidores deles, com infraestrutura escal√°vel.
‚Ä¢	Voc√™ acompanha os resultados em tempo real pelo navegador (dashboard K6 Cloud).
‚Ä¢	Seu notebook n√£o gera carga ‚Äî ele s√≥ inicia o teste e exibe o progresso.
‚Ä¢	N√£o precisa manter seu notebook ligado depois de disparar o teste no K6 Cloud.
‚Ä¢	O seu notebook pode:
‚Ä¢	Ser desligado üì¥
‚Ä¢	Perder conex√£o üåê
‚Ä¢	Fechar o terminal üíª
‚Üí e o teste continuar√° rodando normalmente e o resultado poder√° ser visto depois.

------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì 4¬™ etapa
Integra√ß√£o com CI/CD

1- Criar um reposit√≥rio remoto no GitHub, inicializar o git localmente e associar ao reposit√≥rio remoto.
2- Salvar o token do K6 Cloud no GitHub Secrets and variables:
‚Ä¢	V√° em Settings > Secrets and variables > Actions > New repository secret
‚Ä¢	Nome: K6_CLOUD_TOKEN
‚Ä¢	Valor: seu token da Grafana K6 Cloud
3- Criar estrutura de pasta para GitHub Actions: .github/workflows/
4- Com aux√≠lio do ChatGpt crie um arquivo b√°sico para executar o workflow:  teste-k6.yml
‚Ä¢	O arquivo deve rodar a cada push
‚Ä¢	Deve ter op√ß√£o de execu√ß√£o manual ‚Äúworkflow_dispatch‚Äù
‚Ä¢	Deve utilizar a vari√°vel secret do token

CONCLUS√ÉO:
Foi observado que mesmo executando o comando k6 cloud, o workflow permanece aguardando o final dos testes de performance, ou seja, o GitHub Actions vai ficar em execu√ß√£o (em progresso) enquanto o teste roda, mesmo sendo na nuvem. Se seu script simula milhares de usu√°rios simult√¢neos e roda por v√°rios minutos, a pipeline vai ficar aberta e ocupada durante todo esse per√≠odo.
A pipeline n√£o pode "apenas disparar" e terminar imediatamente ‚Äî porque o comando k6 cloud √© s√≠ncrono e espera o teste finalizar. Por padr√£o, o k6 cloud espera o teste terminar antes de encerrar.

üí° 
Pesquisei por uma alternativa que disparasse a execu√ß√£o dos testes na cloud do K6 e encerrasse o workflow com sucesso antes do termino dos testes, capturando a URL para acompanhamento dos resultados dos testes de performance no Grafana.
Utilizei a flag --exit-on-running que permite iniciar a execu√ß√£o do script na nuvem e assim que gerar a URL encerrar o processo na m√°quina local sem esperar o t√©rmino da execu√ß√£o no K6 Cloud.
‚úÖResultado:
‚Ä¢	A pipeline dispara o teste na nuvem 
‚Ä¢	Exibe a URL na interface do GitHub Actions
‚Ä¢	E encerra imediatamente com sucesso


Queria que abrisse uma janela com esta URL capturada como parte da execu√ß√£o da pipeline.
R: Mas o GitHub Actions n√£o consegue abrir janelas ou navegar automaticamente para URLs no navegador do usu√°rio. O GitHub Actions roda em servidores da GitHub, n√£o na sua m√°quina. Ele n√£o tem acesso ao seu navegador ou desktop local. N√£o h√° como "abrir uma aba" no seu navegador a partir de um script executado remotamente.

Sugest√µes extras
Voc√™ pode configurar:
‚Ä¢	Notifica√ß√£o no Slack ou Discord
‚Ä¢	E-mail autom√°tico com a URL
‚Ä¢	Mensagem no Telegram ou Teams

Caminho para executar manualmente:
1.	Acesse o seu reposit√≥rio no GitHub depois na aba "Actions".
2.	Na lateral esquerda, clique no nome do seu workflow (por exemplo: Teste de Performance com K6 na Cloud).
3.	Clique no bot√£o ‚ÄúRun workflow‚Äù para iniciar a execu√ß√£o (fica no lado direito da tela).

------------------------------------------------------------------------------------------------------------------------------------------


Projeto ‚Äì 5¬™ etapa
Aplica√ß√£o de cada tipo de teste de performance

1- Estudo de conceitos, comparativos, cen√°rios e casos reais referentes a cada tipo de teste de performance.

O K6 por padr√£o s√≥ executa o que voc√™ manda, ou seja, ele n√£o interpreta HTML nem executa JavaScript como um navegador real faria. Quando voc√™ manda http.get(‚Äòhttps://www.google.com‚Äô) o K6 abre uma conex√£o com o servidor, baixa o HTML da p√°gina e fecha a conex√£o. Ele n√£o carrega scripts, imagens ou estilos que o navegador normalmente carregaria depois.
Uma conex√£o ativa √© quando um usu√°rio interage com a p√°gina e outras requisi√ß√µes s√£o realizadas como POST para enviar dados ou GET para carregar tabelas por exemplo. Algumas p√°ginas carregam informa√ß√µes automaticamente como publicidades, bolsa valores etc sem intera√ß√£o do usu√°rio. No K6, cada VU (usu√°rio virtual) acessa a p√°gina, espera alguns segundos (sleep) e depois realiza novo acesso simulando uma intera√ß√£o com a p√°gina. O ‚Äúsleep(5)‚Äù, por exemplo, seria o tempo que o usu√°rio passa olhando a tela sem fazer nada por 5 segundos at√© voltar a interagir (fazer nova requisi√ß√£o como F5).
Acesso cont√≠nuo s√£o usu√°rios virtuais (VUs) executando requisi√ß√µes de forma constante e repetida durante todo o teste. √â quando um usu√°rio virtual (VU) faz uma requisi√ß√£o (ex: http.get()), espera um pequeno tempo (como sleep(1)), e repete esse ciclo sem parar, at√© o final do teste. Isso √© considerado um cen√°rio de acesso cont√≠nuo, pois os usu√°rios n√£o pausam por longos per√≠odos, nem entram/saem do sistema. Por padr√£o, K6 usa conex√µes HTTP/1.1 com keep-alive habilitado, o que permite reusar a mesma conex√£o TCP para v√°rias requisi√ß√µes seguidas ‚Äî inclusive entre os ciclos com sleep(). Em acessos cont√≠nuos com sleep(), a conex√£o geralmente √© mantida (keep-alive), n√£o sendo reaberta a cada requisi√ß√£o, desde que o servidor permita. Isso torna o teste mais realista e eficiente. Se o sleep() for alto, a reutiliza√ß√£o da conex√£o TCP/HTTP depende do tempo de inatividade aceito pelo servidor e do pr√≥prio K6, pode causar fechamento da conex√£o.


TIPOS DE TESTE DE PERFORMANCE

 

üß† Resumo Comparativo
Tipo de Teste	Objetivo	Carga ao longo do tempo	Quando usar
Carga	Ver se o sistema suporta uso real	Carga constante	Uso normal ou pico m√©dio previsto
Estresse	Encontrar o limite do sistema	Carga crescente at√© falhar	Saber at√© onde ele aguenta
Pico	Testar rea√ß√£o a acessos bruscos	Pico s√∫bito e retorno	Eventos inesperados


1. Teste de Carga (Load Test)
Avalia o comportamento do sistema sob uso esperado ou ligeiramente acima do normal. Simula usu√°rios reais por tempo cont√≠nuo.
Exemplo real:
Um e-commerce que geralmente tem cerca de 10 mil usu√°rios simult√¢neos acessando durante o dia normal de vendas, e voc√™ quer garantir que o site aguente essa carga com boa resposta.

‚öôÔ∏è Configura√ß√£o t√≠pica:
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  vus: 50,
  duration: '1m',
};

export default function () {
  const res = http.get('https://example.com');

  check(res, {
    'status is 200': (r) => r.status === 200,
  });

  sleep(1);
}

‚Ä¢	Os 50 usu√°rios virtuais (VUs) permanecem ativos simultaneamente durante todo o tempo, executando requisi√ß√µes continuamente durante 1 minuto.
‚Ä¢	Cada VU faz 1 requisi√ß√£o por segundo ‚Üí 50 √ó 60 = 3.000 requisi√ß√µes no total.
O sleep(1) faz com que cada VU:
‚Ä¢	Fa√ßa uma requisi√ß√£o
‚Ä¢	Espere 1 segundo
‚Ä¢	Repita o ciclo
‚Ä¢	A carga come√ßa imediatamente com 50 VUs fixas (sem stages ou ramp-up).
‚Ä¢	Mant√©m uma carga constante e previs√≠vel ‚Äî ideal para testes de carga est√°vel.
‚Ä¢	√ötil para observar consumo de recursos sob uso sustentado.
‚Ä¢	K6 inicia imediatamente com 50 VUs e mant√©m esse n√∫mero constante durante os 2 minutos.
‚Ä¢	√â uma carga est√°vel desde o segundo 0 at√© o fim.
‚Ä¢	 N√£o h√° ramp-up (aumento gradual).
Aplica√ß√£o t√≠pica:
Esse formato √© mais usado para testes de p√°ginas web ou sistemas onde o comportamento do usu√°rio (espera entre a√ß√µes) importa.

________________________________________
2. Teste de Estresse (Stress Test)
Verifica at√© onde o sistema aguenta carga crescente at√© come√ßar a falhar (descobrir limite m√°ximo).
Exemplo real:
Um sistema banc√°rio onde voc√™ quer identificar quantas requisi√ß√µes simult√¢neas ele aguenta at√© que as respostas comecem a falhar ou atrasar demais.

‚öôÔ∏è Configura√ß√£o com ramp-up:
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 50 },   // sobe at√© 50 VUs
    { duration: '30s', target: 100 },  // sobe at√© 100 VUs
    { duration: '30s', target: 200 },  // sobe at√© 200 VUs
    { duration: '30s', target: 0 },    // finaliza o teste
  ],
};

export default function () {
  const res = http.get('https://example.com');

  check(res, {
    'status is 200': (r) => r.status === 200,
  });

  sleep(1);
}
‚Ä¢	A carga aumenta gradualmente para descobrir o ponto de falha do sistema.
‚Ä¢	Serve para identificar gargalos, limites de CPU/mem√≥ria, queda de performance.
Aplica√ß√£o t√≠pica:
Tamb√©m indicado para p√°ginas web e aplica√ß√µes front-end que precisam simular aumento gradual de usu√°rios reais interagindo, com tempo de espera entre a√ß√µes.


Explicando cada etapa
1. { duration: '30s', target: 50 }
‚Ä¢	O K6 ir√° aumentar gradualmente de 0 at√© 50 VUs ao longo de 30 segundos.
‚Ä¢	Ou seja, nem todos os 50 VUs estar√£o ativos durante os 30s inteiros.
‚Ä¢	Resultado: menor que 50√ó30/1 = 1500 requisi√ß√µes ser√£o feitas, pois os VUs v√£o surgindo aos poucos.

2. { duration: '30s', target: 100 }
‚Ä¢	Aumenta de 50 at√© 100 VUs durante 30 segundos.
‚Ä¢	Aqui sim, os 50 primeiros VUs j√° est√£o ativos no in√≠cio dessa etapa.
‚Ä¢	Mas, como os demais VUs (at√© 100) entram gradualmente, voc√™ n√£o ter√° 100 VUs durante todos os 30 segundos.
‚Ä¢	Resultado: menos que 100√ó30 = 3000 requisi√ß√µes.

3. { duration: '30s', target: 0 }
‚Ä¢	O K6 reduz gradualmente de 200 para 0 VUs.
‚Ä¢	Isso n√£o significa 0 requisi√ß√µes durante os 30s, mas sim uma diminui√ß√£o progressiva at√© parar completamente.
‚Ä¢	Resultado: VUs ainda fazem requisi√ß√µes no in√≠cio, que v√£o diminuindo at√© zerar ao final dos 30s.

________________________________________
3. Teste de Pico (Spike Test)
Avalia como o sistema reage a um aumento repentino (pico) de usu√°rios.
Exemplo real:
Um site de ingressos para shows que abre venda em hor√°rio marcado e espera uma s√∫bita alta no acesso no momento da libera√ß√£o.

‚öôÔ∏è Configura√ß√£o:
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '10s', target: 10 },   // come√ßa com 10 usu√°rios
    { duration: '5s', target: 200 },   // pico repentino para 200
    { duration: '10s', target: 10 },   // volta para 10
    { duration: '10s', target: 0 },    // encerra
  ],
};

export default function () {
  const res = http.get('https://example.com');

  check(res, {
    'status is 200': (r) => r.status === 200,
  });

  sleep(1);
}
‚Ä¢	O sistema sofre um pico s√∫bito de carga (ex: promo√ß√£o, evento ao vivo).
‚Ä¢	Verificamos se ele responde, mant√©m estabilidade e se recupera ap√≥s o pico.
________________________________________


Tempo que devo considerar em cada teste:

Carga: entre 5 e 60 minutos costuma ser suficiente para simular um cen√°rio de uso cont√≠nuo e medir estabilidade, uso de recursos (CPU, RAM), e throughput.

Stress: de 5 a 60 minutos √© o mais comum. Aqui o foco √© intensidade, n√£o dura√ß√£o. Voc√™ aumenta a carga al√©m do esperado rapidamente. Come√ßa com 100 usu√°rios, sobe para 200, depois 500, at√© o sistema falhar.

Pico: bem curta, geralmente segundos ou poucos minutos.

________________________________________

M√©trica (Usu√°rios VU x Requisi√ß√µes RPS)  que devo considerar em cada teste:

Em testes de carga, o que √© mais relevante: n√∫mero de requisi√ß√µes ou de usu√°rios?
üéØ Depende do seu objetivo, mas na maioria dos casos: n√∫mero de usu√°rios
Porque:
‚Ä¢	O comportamento do sistema na vida real depende de usu√°rios simult√¢neos (concorr√™ncia), n√£o apenas da quantidade bruta de requisi√ß√µes.
‚Ä¢	Exemplo:
10.000 requisi√ß√µes feitas por 10 usu√°rios ao longo de horas ‚â† 10.000 requisi√ß√µes feitas por 1.000 usu√°rios ao mesmo tempo em 1 minuto.
Usu√°rios simult√¢neos afetam:
‚Ä¢	Concorr√™ncia no banco de dados
‚Ä¢	Sess√µes abertas
‚Ä¢	Locks e filas
‚Ä¢	Threads do servidor
‚Ä¢	Escalabilidade
________________________________________
üî∏ quando considerar requisi√ß√µes por segundo (RPS)?
Quando o foco for capacidade de throughput:
‚Ä¢	Ex: sistemas de APIs que precisam aguentar X requisi√ß√µes/segundo.
Muito √∫til em:
‚Ä¢	Gateways
‚Ä¢	APIs REST
‚Ä¢	Microservi√ßos
‚Ä¢	Load Balancers


 



üõí 1. Simula√ß√£o de site em Black Friday (usu√°rios simult√¢neos - VUs)
‚Ä¢	Simula crescimento org√¢nico de tr√°fego
‚Ä¢	Reproduz o comportamento humano real
‚Ä¢	Ideal para testar frontend e backend juntos (ex: navega√ß√£o, sess√µes, banco de dados)

import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 0 },     // inicia sem usu√°rios
    { duration: '2m', target: 500 },   // sobe gradualmente at√© 500 usu√°rios
    { duration: '3m', target: 500 },   // mant√©m 500 usu√°rios ativos
    { duration: '1m', target: 0 },     // finaliza reduzindo os acessos
  ],
};

export default function () {
  const res = http.get('https://example.com');  // simula o carregamento da home ou p√°gina

  check(res, {
    'status is 200': (r) => r.status === 200,
  });

  sleep(1);  // simula leitura/navega√ß√£o
}
________________________________________
üîó 2. Teste de API REST com foco em throughput (requisi√ß√µes por segundo - RPS)
‚Ä¢	Mant√©m a taxa de requisi√ß√µes est√°vel, independentemente da quantidade de VUs
Ideal para:
‚Ä¢	Testar resili√™ncia e escalabilidade da API
‚Ä¢	Descobrir o limite de RPS suportado
‚Ä¢	Avaliar lat√™ncia, throughput e erros (HTTP 500, 429, etc.)


import http from 'k6/http';
import { check } from 'k6';

export const options = {
  scenarios: {
    api_rps_test: {
      executor: 'constant-arrival-rate',
      rate: 1000,              // 1000 requisi√ß√µes por segundo
      timeUnit: '1s',
      duration: '1m',
      preAllocatedVUs: 200,    // VUs reservados para dar conta do volume
      maxVUs: 1000,            // limite superior de VUs se necess√°rio
    },
  },
};

export default function () {
  const res = http.get('https://api.example.com/v1/products');  // simula chamada a um endpoint REST

  check(res, {
    'status is 200': (r) => r.status === 200,
  });
}
------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì 6¬™ etapa
Realizando testes em ambientes corporativos

1- Quando voc√™ executa um teste no k6 Cloud, os usu√°rios virtuais (VUs) s√£o simulados diretamente na infraestrutura em nuvem da Grafana Labs (k6), e n√£o no seu notebook. Isso significa que o desempenho do seu computador n√£o afeta o teste, j√° que toda a carga √© gerada pelos servidores do k6 Cloud.
Ao executar um teste no K6 Cloud:
Os usu√°rios virtuais (VUs) s√£o gerados em servidores da infraestrutura do K6 (baseados na nuvem).
Seu notebook apenas envia o script e inicia o teste, mas n√£o √© respons√°vel pela execu√ß√£o das requisi√ß√µes de carga.
Isso significa que n√£o consome CPU, mem√≥ria ou largura de banda da sua m√°quina local durante o teste.

2- Se a URL ou API que voc√™ est√° testando estiver em um ambiente interno da sua empresa (n√£o acess√≠vel publicamente na internet), o k6 Cloud n√£o conseguir√° acess√°-la diretamente

1. Usando o k6 Agent
O k6 Agent √© um componente leve que voc√™ instala dentro da sua rede interna (ex.: em um servidor, VM ou at√© mesmo no seu notebook).
Ele age como um proxy reverso, permitindo que os testes executados no k6 Cloud se comuniquem com sistemas internos.
Como funciona?
O k6 Cloud envia as requisi√ß√µes para o Agent, que est√° dentro da sua rede.
O Agent redireciona essas requisi√ß√µes para o sistema interno.
As respostas s√£o enviadas de volta ao k6 Cloud via Agent.

2. Expondo temporariamente o endpoint interno via VPN/SSH Tunnel
Se sua empresa tem uma VPN ou permite t√∫neis SSH, voc√™ pode configurar um acesso tempor√°rio para o k6 Cloud.

3. Usando um IP p√∫blico tempor√°rio (n√£o recomendado para ambientes seguros)
Riscos: Isso pode trazer vulnerabilidades de seguran√ßa, ent√£o s√≥ deve ser feito em ambientes controlados.


Recomenda√ß√£o:
Para testes em APIs/sites internos, o k6 Agent √© a solu√ß√£o mais segura e recomendada.



O k6 Agent pode ser instalado e executado em um pipeline CI/CD (como GitHub Actions, GitLab CI, Jenkins, etc.), permitindo que testes de carga no k6 Cloud acessem sistemas internos durante a execu√ß√£o automatizada.

Exemplo Pr√°tico (GitHub Actions)
Aqui est√° um exemplo de como configurar o k6 Agent em um pipeline do GitHub Actions:
1. Workflow YAML (k6-load-test.yml)

name: k6 Load Test with Agent  
on: [push]  

jobs:  
  k6-load-test:  
    runs-on: ubuntu-latest  # Ou um self-hosted runner dentro da sua rede  
    steps:  
      - name: Checkout  
        uses: actions/checkout@v4  

      - name: Install k6 Agent  
        run: |  
          curl -L https://github.com/grafana/k6/releases/download/v0.47.0/k6-agent-linux-amd64.tar.gz | tar xz  
          chmod +x k6-agent  

      - name: Start k6 Agent (em background)  
        run: |  
          ./k6-agent --cloud-token ${{ secrets.K6_CLOUD_TOKEN }} &  
          sleep 5  # Aguarda o Agent inicializar  

      - name: Run k6 Cloud Test  
        run: |  
          k6 cloud --token ${{ secrets.K6_CLOUD_TOKEN }} script.js  

      - name: Stop k6 Agent  
        run: pkill k6-agent  # Encerra o Agent ap√≥s o teste  




Para iniciar testes com K6 em ambiente corporativo devemos considerar instala√ß√£o em m√°quina local ou servidor da empresa?

1. Instalar em sua m√°quina local (dev/QA)
Pr√≥s:
Ideal para desenvolvimento dos scripts de testes antes de escalar.
Controle total: Facilidade de configura√ß√£o e execu√ß√£o sem burocracia corporativa.
Ambiente isolado: N√£o impacta a infraestrutura da empresa.
Simula√ß√µes r√°pidas de carga com poucos usu√°rios virtuais VUs (em APIs internas ou ambientes de homologa√ß√£o)
Valida√ß√£o de performance durante o desenvolvimento (ex: via VS Code + terminal)

Contras:
Recursos limitados: Sua m√°quina pode n√£o ter capacidade para simular carga alta (ex: milhares de usu√°rios virtuais).
Depend√™ncia da sua conex√£o: A rede local pode distorcer resultados (lat√™ncia, banda).
Problemas de compliance: Dados sens√≠veis podem n√£o poder ser testados localmente.


2. Instalar em um servidor corporativo
Pr√≥s:
Capacidade de carga maior: Servidores geralmente t√™m mais CPU, RAM e rede est√°vel.
Ambiente controlado: Mais pr√≥ximo do cen√°rio real de produ√ß√£o (ex: mesma rede/VPC).
Integra√ß√£o com CI/CD: Facilita testes automatizados em pipelines (ex: Jenkins, GitLab CI).
Conformidade com pol√≠ticas: Atende a requisitos de seguran√ßa e governan√ßa.
Instala√ß√£o em um servidor (m√°quina dedicada ou cloud)

Contras:
Burocracia: Pode exigir aprova√ß√µes de TI/Seguran√ßa para instalar ferramentas.
Configura√ß√£o complexa: Proxy, firewalls ou restri√ß√µes de sa√≠da podem exigir ajustes.


Exemplo de Fluxo Corporativo:
1. Desenvolver script no seu PC ‚Üí `k6 run script.js` (testes pequenos).
2. Subir para um reposit√≥rio Git (ex: GitHub/GitLab da empresa).
3. Executar em um servidor de CI/CD ou container com: k6 run scripts/teste-basico.js

Comando para executar os testes no K6 Cloud: k6 cloud scripts/teste-basico.js

------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì 7¬™ etapa
Criar teste de carga em API

1- Iniciar o teste com um endpoint isolado e depois evoluir para um fluxo
2- Testar APIs integradas . Testar uma ou v√°rias APIs que interagem com outras APIs internas ou externas. Seu foco pode ser testar um sistema ou v√°rios.
3- Testando fluxos de API de ponta a ponta . Simulando intera√ß√µes realistas entre APIs para testar o sistema como um todo

Analisando exemplo b√°sico:
import http from 'k6/http';

export const options = {
  vus: 50,
  duration: '30s',
};

export default function () {
  const payload = JSON.stringify({
    name: 'lorem',
    surname: 'ipsum',
  });
  const headers = { 'Content-Type': 'application/json' };
  http.post('https://quickpizza.grafana.com/api/post', payload, { headers });
}

Os 50 usu√°rios virtuais (VUs) s√£o executados juntos ou gradualmente?
export const options = {
  vus: 50,
  duration: '30s',
};
Os 50 usu√°rios virtuais s√£o iniciados imediatamente, ou seja, todos come√ßam ao mesmo tempo, mantendo esse n√∫mero constante durante os 30 segundos.
N√£o h√° ramp-up (aumento gradual de usu√°rios) ‚Äî esse comportamento s√≥ aconteceria se voc√™ usasse stages (como no teste de stress ou soak).


O que significa "executam continuamente por 30 segundos"?
Significa que cada VU executa o default function() em loop durante 30 segundos.
Como n√£o h√° sleep() no c√≥digo, assim que uma requisi√ß√£o termina, o VU faz outra imediatamente.
Ou seja:
Cada VU envia o m√°ximo de requisi√ß√µes POST que conseguir no tempo dispon√≠vel (em 30 segundos), uma ap√≥s a outra, sem pausa.


Ser√£o exatamente 50 √ó 30 = 1.500 requisi√ß√µes?
N√£o exatamente.
Esse c√°lculo s√≥ seria v√°lido se cada VU fizesse 1 requisi√ß√£o por segundo, o que n√£o acontece aqui, pois:
‚Ä¢	Cada VU faz m√∫ltiplas requisi√ß√µes por segundo, dependendo da velocidade da resposta da API.
‚Ä¢	Ent√£o, no total, o n√∫mero de requisi√ß√µes tende a ser muito maior do que 1.500.
Exemplo realista:
Suponha que a requisi√ß√£o POST leve 200ms (0,2s) para ser respondida.
‚Ä¢	Cada VU consegue fazer 5 requisi√ß√µes por segundo (1 √∑ 0,2 = 5).
‚Ä¢	Ent√£o:
50 VUs √ó 5 req/s √ó 30 s = 7.500 requisi√ß√µes no total.
Se a API for muito r√°pida, o n√∫mero pode ser ainda maior.


Dica:
Se quiser controlar a frequ√™ncia, voc√™ pode usar sleep(1) dentro da fun√ß√£o:
export default function () {
  http.post(...);
  sleep(1); // pausa de 1 segundo entre requisi√ß√µes
}
A√≠ sim cada VU faria 1 requisi√ß√£o por segundo, e o c√°lculo 50 √ó 30 = 1.500 se tornaria v√°lido.






------------------------------------------------------------------------------------------------------------------------------------------



Projeto ‚Äì x¬™ etapa
An√°lise dos resultados

1- Analisar o resultado dos testes acessando Grafana K6 Testing & synthetics > Performance > Projects > Clica no nome do projeto > ser√° exibido um gr√°fico de colunas, basta clicar em qualquer coluna para analisar os dados.

Principais M√©tricas no Grafana k6 Cloud
1. Requests per second (RPS)
‚Ä¢	O que √©: Quantas requisi√ß√µes foram feitas por segundo.
‚Ä¢	O que analisar: Est√° de acordo com o esperado? (Ex: 10 VUs com http.get() cont√≠nuo + sem sleep = alto RPS, geralmente 100+ RPS).
‚Ä¢	Alvo: Estabilidade e crescimento controlado, sem quedas ou picos inexplic√°veis.
2. HTTP Req Duration (lat√™ncia de resposta)
‚Ä¢	O que √©: Tempo total que uma requisi√ß√£o leva do envio √† resposta.
‚Ä¢	Indicadores chave:
o	p(90) ‚Üí 90% das requisi√ß√µes foram mais r√°pidas que este tempo.
o	p(95) e p(99) ‚Üí ajudam a ver outliers (requisi√ß√µes lentas).
‚Ä¢	Alvo: Consist√™ncia e valores abaixo de 300ms para bons sistemas (varia por caso).
3. Checks
‚Ä¢	O que √©: Valida√ß√£o do status 200 que voc√™ escreveu no check.
‚Ä¢	O que analisar: Se 100% passaram, √≥timo. Se houver falhas, algo na aplica√ß√£o n√£o est√° respondendo corretamente.
4. Errors
‚Ä¢	O que √©: Quaisquer erros de conex√£o, timeout, falhas no check etc.
‚Ä¢	O que analisar: Ideal √© 0 erros. Se houver, verificar c√≥digo, instabilidade no endpoint, ou problema de rede.
5. VU metrics
‚Ä¢	Executions per second: Mede a frequ√™ncia com que cada VU consegue executar a default function.
‚Ä¢	Se os VUs estiverem sobrecarregados ou lentos, voc√™ ver√° isso aqui.
________________________________________
üí° Interpreta√ß√£o de Exemplo com seu c√≥digo:
‚Ä¢	Expected RPS: Cerca de 80‚Äì120 requests/s com 10 VUs por 10s (varia conforme o tempo de resposta do servidor).
‚Ä¢	Check success rate: 100% se https://test.k6.io respondeu com status 200 sempre.
‚Ä¢	p(95) Req Duration: Idealmente < 300ms. Se estiver > 1s, indica lentid√£o no servidor.
________________________________________
üìä Extras √∫teis no painel:
‚Ä¢	Trends over time: Veja se h√° aumento de lat√™ncia ou erros ao longo dos 10s.
‚Ä¢	VU Load Distribution: Se quiser ver se todos os VUs est√£o contribuindo igualmente.
 


 




Projeto ‚Äì X¬™ etapa
Usando gravador no navegador

1- O gravador de navegador permite gerar um script k6 com base em uma sess√£o do navegador. Est√° dispon√≠vel como uma extens√£o para Chrome e Firefox .




